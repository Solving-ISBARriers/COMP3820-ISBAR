{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nexports.KEY = settings_1.SMART_KEY;\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n * @param [_noRedirect] If true, resolve with the redirect url without trying to redirect to it\n */\n\nasync function authorize(env, params = {}, _noRedirect = false) {\n  // Obtain input\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height,\n    completeInTarget\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    scope = \"\",\n    clientId\n  } = params;\n  const url = env.getUrl();\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (_noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b, _c, _d;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %O\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  if (!key) {\n    throw new Error(\"No 'state' parameter found. Please (re)launch the app.\");\n  } // Check if we have a previous state\n\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  if (!state) {\n    throw new Error(\"No state found! Please (re)launch the app.\");\n  } // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n\n  const authorized = !code || ((_b = (_a = state) === null || _a === void 0 ? void 0 : _a.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    if (!code) {\n      throw new Error(\"'code' url parameter is required\");\n    }\n\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n\n    if (!tokenResponse.access_token) {\n      throw new Error(\"Failed to obtain access token.\");\n    } // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_d = (_c = state) === null || _c === void 0 ? void 0 : _c.tokenResponse) === null || _d === void 0 ? void 0 : _d.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n\n  if (!redirectUri) {\n    throw new Error(\"Missing state.redirectUri\");\n  }\n\n  if (!tokenUri) {\n    throw new Error(\"Missing state.tokenUri\");\n  }\n\n  if (!clientId) {\n    throw new Error(\"Missing state.clientId\");\n  }\n\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;","map":{"version":3,"sources":["/Users/myoungseokjeong/Desktop/Masters/COMP3820_digital_health_software_project/Code/COMP3820-ISBAR/isbar-simple-react/node_modules/fhirclient/lib/smart.js"],"names":["Object","defineProperty","exports","value","lib_1","require","Client_1","settings_1","KEY","SMART_KEY","debug","extend","isBrowser","window","fetchWellKnownJson","baseUrl","requestOptions","url","String","replace","getAndCache","catch","ex","Error","message","getSecurityExtensionsFromWellKnownJson","then","meta","authorization_endpoint","token_endpoint","registrationUri","registration_endpoint","authorizeUri","tokenUri","getSecurityExtensionsFromConformanceStatement","fetchConformanceStatement","nsUri","extensions","getPath","filter","e","map","o","extension","out","forEach","ext","valueUri","any","tasks","len","length","errors","resolved","Promise","resolve","reject","onSuccess","task","result","complete","t","controller","abort","onError","error","push","join","promise","getSecurityExtensions","env","AbortController","getAbortController","abortController1","abortController2","signal","authorize","params","_noRedirect","redirect_uri","clientSecret","fakeTokenResponse","patientId","encounterId","client_id","target","width","height","completeInTarget","iss","launch","fhirServiceUrl","redirectUri","scope","clientId","getUrl","storage","getStorage","searchParams","get","relative","serverUrl","match","oldKey","unset","stateKey","randomString","state","tokenResponse","key","fullSessionStorageSupport","set","assign","patient","encounter","redirectUrl","encodeURIComponent","redirect","redirectParams","win","getTargetWindow","self","sessionStorage","removeItem","setItem","JSON","stringify","location","href","addEventListener","onMessage","isInFrame","top","parent","isInPopUp","opener","name","data","type","origin","URL","removeEventListener","completeAuth","_a","_b","_c","_d","Storage","code","authError","authErrorDescription","Boolean","inFrame","inPopUp","postMessage","close","delete","hasState","has","history","replaceState","authorized","access_token","buildTokenRequest","request","client","default","method","headers","body","Authorization","btoa","ready","init","options","cached"],"mappings":"AAAA;;AAEAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAC3CC,EAAAA,KAAK,EAAE;AADoC,CAA7C;AAGA;;AAEA,MAAMC,KAAK,GAAGC,OAAO,CAAC,OAAD,CAArB;;AAEA,MAAMC,QAAQ,GAAGD,OAAO,CAAC,UAAD,CAAxB;;AAEA,MAAME,UAAU,GAAGF,OAAO,CAAC,YAAD,CAA1B;;AAEAH,OAAO,CAACM,GAAR,GAAcD,UAAU,CAACE,SAAzB;AACA,MAAMC,KAAK,GAAGN,KAAK,CAACM,KAAN,CAAYC,MAAZ,CAAmB,QAAnB,CAAd;;AAEA,SAASC,SAAT,GAAqB;AACnB,SAAO,OAAOC,MAAP,KAAkB,QAAzB;AACD;AACD;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,kBAAT,CAA4BC,OAAO,GAAG,GAAtC,EAA2CC,cAA3C,EAA2D;AACzD,QAAMC,GAAG,GAAGC,MAAM,CAACH,OAAD,CAAN,CAAgBI,OAAhB,CAAwB,MAAxB,EAAgC,GAAhC,IAAuC,iCAAnD;AACA,SAAOf,KAAK,CAACgB,WAAN,CAAkBH,GAAlB,EAAuBD,cAAvB,EAAuCK,KAAvC,CAA6CC,EAAE,IAAI;AACxD,UAAM,IAAIC,KAAJ,CAAW,wCAAuCN,GAAI,MAAKK,EAAE,CAACE,OAAQ,EAAtE,CAAN;AACD,GAFM,CAAP;AAGD;;AAEDtB,OAAO,CAACY,kBAAR,GAA6BA,kBAA7B;AACA;AACA;AACA;;AAEA,SAASW,sCAAT,CAAgDV,OAAO,GAAG,GAA1D,EAA+DC,cAA/D,EAA+E;AAC7E,SAAOF,kBAAkB,CAACC,OAAD,EAAUC,cAAV,CAAlB,CAA4CU,IAA5C,CAAiDC,IAAI,IAAI;AAC9D,QAAI,CAACA,IAAI,CAACC,sBAAN,IAAgC,CAACD,IAAI,CAACE,cAA1C,EAA0D;AACxD,YAAM,IAAIN,KAAJ,CAAU,uBAAV,CAAN;AACD;;AAED,WAAO;AACLO,MAAAA,eAAe,EAAEH,IAAI,CAACI,qBAAL,IAA8B,EAD1C;AAELC,MAAAA,YAAY,EAAEL,IAAI,CAACC,sBAFd;AAGLK,MAAAA,QAAQ,EAAEN,IAAI,CAACE;AAHV,KAAP;AAKD,GAVM,CAAP;AAWD;AACD;AACA;AACA;;;AAGA,SAASK,6CAAT,CAAuDnB,OAAO,GAAG,GAAjE,EAAsEC,cAAtE,EAAsF;AACpF,SAAOZ,KAAK,CAAC+B,yBAAN,CAAgCpB,OAAhC,EAAyCC,cAAzC,EAAyDU,IAAzD,CAA8DC,IAAI,IAAI;AAC3E,UAAMS,KAAK,GAAG,uEAAd;AACA,UAAMC,UAAU,GAAG,CAACjC,KAAK,CAACkC,OAAN,CAAcX,IAAI,IAAI,EAAtB,EAA0B,2BAA1B,KAA0D,EAA3D,EAA+DY,MAA/D,CAAsEC,CAAC,IAAIA,CAAC,CAACvB,GAAF,KAAUmB,KAArF,EAA4FK,GAA5F,CAAgGC,CAAC,IAAIA,CAAC,CAACC,SAAvG,EAAkH,CAAlH,CAAnB;AACA,UAAMC,GAAG,GAAG;AACVd,MAAAA,eAAe,EAAE,EADP;AAEVE,MAAAA,YAAY,EAAE,EAFJ;AAGVC,MAAAA,QAAQ,EAAE;AAHA,KAAZ;;AAMA,QAAII,UAAJ,EAAgB;AACdA,MAAAA,UAAU,CAACQ,OAAX,CAAmBC,GAAG,IAAI;AACxB,YAAIA,GAAG,CAAC7B,GAAJ,KAAY,UAAhB,EAA4B;AAC1B2B,UAAAA,GAAG,CAACd,eAAJ,GAAsBgB,GAAG,CAACC,QAA1B;AACD;;AAED,YAAID,GAAG,CAAC7B,GAAJ,KAAY,WAAhB,EAA6B;AAC3B2B,UAAAA,GAAG,CAACZ,YAAJ,GAAmBc,GAAG,CAACC,QAAvB;AACD;;AAED,YAAID,GAAG,CAAC7B,GAAJ,KAAY,OAAhB,EAAyB;AACvB2B,UAAAA,GAAG,CAACX,QAAJ,GAAea,GAAG,CAACC,QAAnB;AACD;AACF,OAZD;AAaD;;AAED,WAAOH,GAAP;AACD,GA1BM,CAAP;AA2BD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASI,GAAT,CAAaC,KAAb,EAAoB;AAClB,QAAMC,GAAG,GAAGD,KAAK,CAACE,MAAlB;AACA,QAAMC,MAAM,GAAG,EAAf;AACA,MAAIC,QAAQ,GAAG,KAAf;AACA,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,aAASC,SAAT,CAAmBC,IAAnB,EAAyBC,MAAzB,EAAiC;AAC/BD,MAAAA,IAAI,CAACE,QAAL,GAAgB,IAAhB;;AAEA,UAAI,CAACP,QAAL,EAAe;AACbA,QAAAA,QAAQ,GAAG,IAAX;AACAJ,QAAAA,KAAK,CAACJ,OAAN,CAAcgB,CAAC,IAAI;AACjB,cAAI,CAACA,CAAC,CAACD,QAAP,EAAiB;AACfC,YAAAA,CAAC,CAACC,UAAF,CAAaC,KAAb;AACD;AACF,SAJD;AAKAR,QAAAA,OAAO,CAACI,MAAD,CAAP;AACD;AACF;;AAED,aAASK,OAAT,CAAiBC,KAAjB,EAAwB;AACtB,UAAIb,MAAM,CAACc,IAAP,CAAYD,KAAZ,MAAuBf,GAA3B,EAAgC;AAC9BM,QAAAA,MAAM,CAAC,IAAIjC,KAAJ,CAAU6B,MAAM,CAACX,GAAP,CAAWD,CAAC,IAAIA,CAAC,CAAChB,OAAlB,EAA2B2C,IAA3B,CAAgC,IAAhC,CAAV,CAAD,CAAN;AACD;AACF;;AAEDlB,IAAAA,KAAK,CAACJ,OAAN,CAAcgB,CAAC,IAAI;AACjBA,MAAAA,CAAC,CAACO,OAAF,CAAU1C,IAAV,CAAeiC,MAAM,IAAIF,SAAS,CAACI,CAAD,EAAIF,MAAJ,CAAlC,EAA+CK,OAA/C;AACD,KAFD;AAGD,GAxBM,CAAP;AAyBD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASK,qBAAT,CAA+BC,GAA/B,EAAoCvD,OAAO,GAAG,GAA9C,EAAmD;AACjD,QAAMwD,eAAe,GAAGD,GAAG,CAACE,kBAAJ,EAAxB;AACA,QAAMC,gBAAgB,GAAG,IAAIF,eAAJ,EAAzB;AACA,QAAMG,gBAAgB,GAAG,IAAIH,eAAJ,EAAzB;AACA,SAAOvB,GAAG,CAAC,CAAC;AACVc,IAAAA,UAAU,EAAEW,gBADF;AAEVL,IAAAA,OAAO,EAAE3C,sCAAsC,CAACV,OAAD,EAAU;AACvD4D,MAAAA,MAAM,EAAEF,gBAAgB,CAACE;AAD8B,KAAV;AAFrC,GAAD,EAKR;AACDb,IAAAA,UAAU,EAAEY,gBADX;AAEDN,IAAAA,OAAO,EAAElC,6CAA6C,CAACnB,OAAD,EAAU;AAC9D4D,MAAAA,MAAM,EAAED,gBAAgB,CAACC;AADqC,KAAV;AAFrD,GALQ,CAAD,CAAV;AAWD;;AAEDzE,OAAO,CAACmE,qBAAR,GAAgCA,qBAAhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeO,SAAf,CAAyBN,GAAzB,EAA8BO,MAAM,GAAG,EAAvC,EAA2CC,WAAW,GAAG,KAAzD,EAAgE;AAC9D;AACA,QAAM;AACJC,IAAAA,YADI;AAEJC,IAAAA,YAFI;AAGJC,IAAAA,iBAHI;AAIJC,IAAAA,SAJI;AAKJC,IAAAA,WALI;AAMJC,IAAAA,SANI;AAOJC,IAAAA,MAPI;AAQJC,IAAAA,KARI;AASJC,IAAAA,MATI;AAUJC,IAAAA;AAVI,MAWFX,MAXJ;AAYA,MAAI;AACFY,IAAAA,GADE;AAEFC,IAAAA,MAFE;AAGFC,IAAAA,cAHE;AAIFC,IAAAA,WAJE;AAKFC,IAAAA,KAAK,GAAG,EALN;AAMFC,IAAAA;AANE,MAOAjB,MAPJ;AAQA,QAAM5D,GAAG,GAAGqD,GAAG,CAACyB,MAAJ,EAAZ;AACA,QAAMC,OAAO,GAAG1B,GAAG,CAAC2B,UAAJ,EAAhB,CAvB8D,CAuB5B;;AAElCR,EAAAA,GAAG,GAAGxE,GAAG,CAACiF,YAAJ,CAAiBC,GAAjB,CAAqB,KAArB,KAA+BV,GAArC;AACAE,EAAAA,cAAc,GAAG1E,GAAG,CAACiF,YAAJ,CAAiBC,GAAjB,CAAqB,gBAArB,KAA0CR,cAA3D;AACAD,EAAAA,MAAM,GAAGzE,GAAG,CAACiF,YAAJ,CAAiBC,GAAjB,CAAqB,QAArB,KAAkCT,MAA3C;;AAEA,MAAI,CAACI,QAAL,EAAe;AACbA,IAAAA,QAAQ,GAAGV,SAAX;AACD;;AAED,MAAI,CAACQ,WAAL,EAAkB;AAChBA,IAAAA,WAAW,GAAGb,YAAd;AACD;;AAED,MAAI,CAACa,WAAL,EAAkB;AAChBA,IAAAA,WAAW,GAAGtB,GAAG,CAAC8B,QAAJ,CAAa,GAAb,CAAd;AACD,GAFD,MAEO;AACLR,IAAAA,WAAW,GAAGtB,GAAG,CAAC8B,QAAJ,CAAaR,WAAb,CAAd;AACD;;AAED,QAAMS,SAAS,GAAGnF,MAAM,CAACuE,GAAG,IAAIE,cAAP,IAAyB,EAA1B,CAAxB,CA3C8D,CA2CP;;AAEvD,MAAI,CAACU,SAAL,EAAgB;AACd,UAAM,IAAI9E,KAAJ,CAAU,8DAA8D,4BAAxE,CAAN;AACD;;AAED,MAAIkE,GAAJ,EAAS;AACP/E,IAAAA,KAAK,CAAC,qBAAD,EAAwBgF,MAAM,GAAG,KAAH,GAAW,YAAzC,CAAL;AACD,GAnD6D,CAmD5D;;;AAGF,MAAIA,MAAM,IAAI,CAACG,KAAK,CAACS,KAAN,CAAY,QAAZ,CAAf,EAAsC;AACpCT,IAAAA,KAAK,IAAI,SAAT;AACD,GAxD6D,CAwD5D;AACF;;;AAGA,QAAMU,MAAM,GAAG,MAAMP,OAAO,CAACG,GAAR,CAAY5F,UAAU,CAACE,SAAvB,CAArB;AACA,QAAMuF,OAAO,CAACQ,KAAR,CAAcD,MAAd,CAAN,CA7D8D,CA6DjC;;AAE7B,QAAME,QAAQ,GAAGrG,KAAK,CAACsG,YAAN,CAAmB,EAAnB,CAAjB;AACA,QAAMC,KAAK,GAAG;AACZb,IAAAA,QADY;AAEZD,IAAAA,KAFY;AAGZD,IAAAA,WAHY;AAIZS,IAAAA,SAJY;AAKZrB,IAAAA,YALY;AAMZ4B,IAAAA,aAAa,EAAE,EANH;AAOZC,IAAAA,GAAG,EAAEJ,QAPO;AAQZjB,IAAAA;AARY,GAAd;AAUA,QAAMsB,yBAAyB,GAAGlG,SAAS,KAAKR,KAAK,CAACkC,OAAN,CAAcgC,GAAd,EAAmB,mCAAnB,CAAL,GAA+D,IAA1G;;AAEA,MAAIwC,yBAAJ,EAA+B;AAC7B,UAAMd,OAAO,CAACe,GAAR,CAAYxG,UAAU,CAACE,SAAvB,EAAkCgG,QAAlC,CAAN;AACD,GA9E6D,CA8E5D;;;AAGF,MAAIxB,iBAAJ,EAAuB;AACrBjF,IAAAA,MAAM,CAACgH,MAAP,CAAcL,KAAK,CAACC,aAApB,EAAmC3B,iBAAnC;AACD,GAnF6D,CAmF5D;;;AAGF,MAAIC,SAAJ,EAAe;AACblF,IAAAA,MAAM,CAACgH,MAAP,CAAcL,KAAK,CAACC,aAApB,EAAmC;AACjCK,MAAAA,OAAO,EAAE/B;AADwB,KAAnC;AAGD,GA1F6D,CA0F5D;;;AAGF,MAAIC,WAAJ,EAAiB;AACfnF,IAAAA,MAAM,CAACgH,MAAP,CAAcL,KAAK,CAACC,aAApB,EAAmC;AACjCM,MAAAA,SAAS,EAAE/B;AADsB,KAAnC;AAGD;;AAED,MAAIgC,WAAW,GAAGvB,WAAW,GAAG,SAAd,GAA0BwB,kBAAkB,CAACX,QAAD,CAA9D,CAnG8D,CAmGY;;AAE1E,MAAId,cAAc,IAAI,CAACF,GAAvB,EAA4B;AAC1B/E,IAAAA,KAAK,CAAC,uBAAD,CAAL;AACA,UAAMsF,OAAO,CAACe,GAAR,CAAYN,QAAZ,EAAsBE,KAAtB,CAAN;;AAEA,QAAI7B,WAAJ,EAAiB;AACf,aAAOqC,WAAP;AACD;;AAED,WAAO,MAAM7C,GAAG,CAAC+C,QAAJ,CAAaF,WAAb,CAAb;AACD,GA9G6D,CA8G5D;;;AAGF,QAAM9E,UAAU,GAAG,MAAMgC,qBAAqB,CAACC,GAAD,EAAM+B,SAAN,CAA9C;AACArG,EAAAA,MAAM,CAACgH,MAAP,CAAcL,KAAd,EAAqBtE,UAArB;AACA,QAAM2D,OAAO,CAACe,GAAR,CAAYN,QAAZ,EAAsBE,KAAtB,CAAN,CAnH8D,CAmH1B;;AAEpC,MAAI,CAACA,KAAK,CAAC3E,YAAX,EAAyB;AACvB,QAAI8C,WAAJ,EAAiB;AACf,aAAOqC,WAAP;AACD;;AAED,WAAO,MAAM7C,GAAG,CAAC+C,QAAJ,CAAaF,WAAb,CAAb;AACD,GA3H6D,CA2H5D;;;AAGF,QAAMG,cAAc,GAAG,CAAC,oBAAD,EAAuB,eAAeF,kBAAkB,CAACtB,QAAQ,IAAI,EAAb,CAAxD,EAA0E,WAAWsB,kBAAkB,CAACvB,KAAD,CAAvG,EAAgH,kBAAkBuB,kBAAkB,CAACxB,WAAD,CAApJ,EAAmK,SAASwB,kBAAkB,CAACf,SAAD,CAA9L,EAA2M,WAAWe,kBAAkB,CAACX,QAAD,CAAxO,CAAvB,CA9H8D,CA8H8M;;AAE5Q,MAAIf,MAAJ,EAAY;AACV4B,IAAAA,cAAc,CAACpD,IAAf,CAAoB,YAAYkD,kBAAkB,CAAC1B,MAAD,CAAlD;AACD;;AAEDyB,EAAAA,WAAW,GAAGR,KAAK,CAAC3E,YAAN,GAAqB,GAArB,GAA2BsF,cAAc,CAACnD,IAAf,CAAoB,GAApB,CAAzC;;AAEA,MAAIW,WAAJ,EAAiB;AACf,WAAOqC,WAAP;AACD;;AAED,MAAI9B,MAAM,IAAIzE,SAAS,EAAvB,EAA2B;AACzB,QAAI2G,GAAJ;AACAA,IAAAA,GAAG,GAAG,MAAMnH,KAAK,CAACoH,eAAN,CAAsBnC,MAAtB,EAA8BC,KAA9B,EAAqCC,MAArC,CAAZ;;AAEA,QAAIgC,GAAG,KAAKE,IAAZ,EAAkB;AAChB,UAAI;AACF;AACA;AACAF,QAAAA,GAAG,CAACG,cAAJ,CAAmBC,UAAnB,CAA8BpB,MAA9B;AACAgB,QAAAA,GAAG,CAACG,cAAJ,CAAmBE,OAAnB,CAA2BnB,QAA3B,EAAqCoB,IAAI,CAACC,SAAL,CAAenB,KAAf,CAArC;AACD,OALD,CAKE,OAAOrF,EAAP,EAAW;AACXlB,QAAAA,KAAK,CAACM,KAAN,CAAa,2GAAb,EAAyHY,EAAzH;AACAiG,QAAAA,GAAG,GAAGE,IAAN;AACD;AACF;;AAED,QAAIF,GAAG,KAAKE,IAAZ,EAAkB;AAChB,UAAI;AACFF,QAAAA,GAAG,CAACQ,QAAJ,CAAaC,IAAb,GAAoBb,WAApB;AACAM,QAAAA,IAAI,CAACQ,gBAAL,CAAsB,SAAtB,EAAiCC,SAAjC;AACD,OAHD,CAGE,OAAO5G,EAAP,EAAW;AACXlB,QAAAA,KAAK,CAACM,KAAN,CAAa,qGAAb,EAAmHY,EAAnH;AACAmG,QAAAA,IAAI,CAACM,QAAL,CAAcC,IAAd,GAAqBb,WAArB;AACD;AACF,KARD,MAQO;AACLM,MAAAA,IAAI,CAACM,QAAL,CAAcC,IAAd,GAAqBb,WAArB;AACD;;AAED;AACD,GA7BD,MA6BO;AACL,WAAO,MAAM7C,GAAG,CAAC+C,QAAJ,CAAaF,WAAb,CAAb;AACD;AACF;;AAEDjH,OAAO,CAAC0E,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASuD,SAAT,GAAqB;AACnB,MAAI;AACF,WAAOV,IAAI,KAAKW,GAAT,IAAgBC,MAAM,KAAKZ,IAAlC;AACD,GAFD,CAEE,OAAOjF,CAAP,EAAU;AACV,WAAO,IAAP;AACD;AACF;;AAEDtC,OAAO,CAACiI,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASG,SAAT,GAAqB;AACnB,MAAI;AACF,WAAOb,IAAI,KAAKW,GAAT,IAAgB,CAAC,CAACG,MAAlB,IAA4BA,MAAM,KAAKd,IAAvC,IAA+C,CAAC,CAAC5G,MAAM,CAAC2H,IAA/D;AACD,GAFD,CAEE,OAAOhG,CAAP,EAAU;AACV,WAAO,KAAP;AACD;AACF;;AAEDtC,OAAO,CAACoI,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASJ,SAAT,CAAmB1F,CAAnB,EAAsB;AACpB,MAAIA,CAAC,CAACiG,IAAF,CAAOC,IAAP,IAAe,cAAf,IAAiClG,CAAC,CAACmG,MAAF,KAAa,IAAIC,GAAJ,CAAQnB,IAAI,CAACM,QAAL,CAAcC,IAAtB,EAA4BW,MAA9E,EAAsF;AACpF9H,IAAAA,MAAM,CAACgI,mBAAP,CAA2B,SAA3B,EAAsCX,SAAtC;AACArH,IAAAA,MAAM,CAACkH,QAAP,CAAgBC,IAAhB,GAAuBxF,CAAC,CAACiG,IAAF,CAAOxH,GAA9B;AACD;AACF;;AAEDf,OAAO,CAACgI,SAAR,GAAoBA,SAApB;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeY,YAAf,CAA4BxE,GAA5B,EAAiC;AAC/B,MAAIyE,EAAJ,EAAQC,EAAR,EAAYC,EAAZ,EAAgBC,EAAhB;;AAEA,QAAMjI,GAAG,GAAGqD,GAAG,CAACyB,MAAJ,EAAZ;AACA,QAAMoD,OAAO,GAAG7E,GAAG,CAAC2B,UAAJ,EAAhB;AACA,QAAMpB,MAAM,GAAG5D,GAAG,CAACiF,YAAnB;AACA,MAAIW,GAAG,GAAGhC,MAAM,CAACsB,GAAP,CAAW,OAAX,CAAV;AACA,QAAMiD,IAAI,GAAGvE,MAAM,CAACsB,GAAP,CAAW,MAAX,CAAb;AACA,QAAMkD,SAAS,GAAGxE,MAAM,CAACsB,GAAP,CAAW,OAAX,CAAlB;AACA,QAAMmD,oBAAoB,GAAGzE,MAAM,CAACsB,GAAP,CAAW,mBAAX,CAA7B;;AAEA,MAAI,CAACU,GAAL,EAAU;AACRA,IAAAA,GAAG,GAAG,MAAMsC,OAAO,CAAChD,GAAR,CAAY5F,UAAU,CAACE,SAAvB,CAAZ;AACD,GAb8B,CAa7B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,MAAI4I,SAAS,IAAIC,oBAAjB,EAAuC;AACrC,UAAM,IAAI/H,KAAJ,CAAU,CAAC8H,SAAD,EAAYC,oBAAZ,EAAkC/G,MAAlC,CAAyCgH,OAAzC,EAAkDpF,IAAlD,CAAuD,IAAvD,CAAV,CAAN;AACD;;AAEDzD,EAAAA,KAAK,CAAC,mBAAD,EAAsBmG,GAAtB,EAA2BuC,IAA3B,CAAL,CA5B+B,CA4BQ;;AAEvC,MAAI,CAACvC,GAAL,EAAU;AACR,UAAM,IAAItF,KAAJ,CAAU,wDAAV,CAAN;AACD,GAhC8B,CAgC7B;;;AAGF,MAAIoF,KAAK,GAAG,MAAMwC,OAAO,CAAChD,GAAR,CAAYU,GAAZ,CAAlB;AACA,QAAMC,yBAAyB,GAAGlG,SAAS,KAAKR,KAAK,CAACkC,OAAN,CAAcgC,GAAd,EAAmB,mCAAnB,CAAL,GAA+D,IAA1G,CApC+B,CAoCiF;AAChH;;AAEA,MAAI1D,SAAS,MAAM+F,KAAf,IAAwB,CAACA,KAAK,CAACnB,gBAAnC,EAAqD;AACnD,UAAMgE,OAAO,GAAGrB,SAAS,EAAzB;AACA,UAAMsB,OAAO,GAAGnB,SAAS,EAAzB,CAFmD,CAEtB;AAC7B;AACA;AACA;AACA;AACA;;AAEA,QAAI,CAACkB,OAAO,IAAIC,OAAZ,KAAwB,CAACxI,GAAG,CAACiF,YAAJ,CAAiBC,GAAjB,CAAqB,UAArB,CAA7B,EAA+D;AAC7DlF,MAAAA,GAAG,CAACiF,YAAJ,CAAiBa,GAAjB,CAAqB,UAArB,EAAiC,GAAjC;AACA,YAAM;AACJiB,QAAAA,IADI;AAEJW,QAAAA;AAFI,UAGF1H,GAHJ;;AAKA,UAAIuI,OAAJ,EAAa;AACXnB,QAAAA,MAAM,CAACqB,WAAP,CAAmB;AACjBhB,UAAAA,IAAI,EAAE,cADW;AAEjBzH,UAAAA,GAAG,EAAE+G;AAFY,SAAnB,EAGGW,MAHH;AAID;;AAED,UAAIc,OAAJ,EAAa;AACXlB,QAAAA,MAAM,CAACmB,WAAP,CAAmB;AACjBhB,UAAAA,IAAI,EAAE,cADW;AAEjBzH,UAAAA,GAAG,EAAE+G;AAFY,SAAnB,EAGGW,MAHH;AAIA9H,QAAAA,MAAM,CAAC8I,KAAP;AACD;;AAED,aAAO,IAAIrG,OAAJ,CAAY,MAAM,CAAE,CAApB,CAAP;AACD;AACF;;AAEDrC,EAAAA,GAAG,CAACiF,YAAJ,CAAiB0D,MAAjB,CAAwB,UAAxB,EA1E+B,CA0EM;;AAErC,QAAMC,QAAQ,GAAGhF,MAAM,CAACiF,GAAP,CAAW,OAAX,CAAjB;;AAEA,MAAIlJ,SAAS,MAAMR,KAAK,CAACkC,OAAN,CAAcgC,GAAd,EAAmB,+BAAnB,CAAf,KAAuE8E,IAAI,IAAIS,QAA/E,CAAJ,EAA8F;AAC5F;AACA;AACA;AACA,QAAIT,IAAJ,EAAU;AACRvE,MAAAA,MAAM,CAAC+E,MAAP,CAAc,MAAd;AACAlJ,MAAAA,KAAK,CAAC,sCAAD,CAAL;AACD,KAP2F,CAO1F;AACF;AACA;AACA;AACA;AACA;;;AAGA,QAAImJ,QAAQ,IAAI/C,yBAAhB,EAA2C;AACzCjC,MAAAA,MAAM,CAAC+E,MAAP,CAAc,OAAd;AACAlJ,MAAAA,KAAK,CAAC,uCAAD,CAAL;AACD,KAlB2F,CAkB1F;AACF;AACA;AACA;AACA;AACA;;;AAGA,QAAIG,MAAM,CAACkJ,OAAP,CAAeC,YAAnB,EAAiC;AAC/BnJ,MAAAA,MAAM,CAACkJ,OAAP,CAAeC,YAAf,CAA4B,EAA5B,EAAgC,EAAhC,EAAoC/I,GAAG,CAAC+G,IAAxC;AACD;AACF,GA3G8B,CA2G7B;;;AAGF,MAAI,CAACrB,KAAL,EAAY;AACV,UAAM,IAAIpF,KAAJ,CAAU,4CAAV,CAAN;AACD,GAhH8B,CAgH7B;AACF;;;AAGA,QAAM0I,UAAU,GAAG,CAACb,IAAD,KAAU,CAACJ,EAAE,GAAG,CAACD,EAAE,GAAGpC,KAAN,MAAiB,IAAjB,IAAyBoC,EAAE,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,EAAE,CAACnC,aAA3D,MAA8E,IAA9E,IAAsFoC,EAAE,KAAK,KAAK,CAAlG,GAAsG,KAAK,CAA3G,GAA+GA,EAAE,CAACkB,YAA5H,CAAnB,CApH+B,CAoH+H;AAC9J;;AAEA,MAAI,CAACD,UAAD,IAAetD,KAAK,CAAC1E,QAAzB,EAAmC;AACjC,QAAI,CAACmH,IAAL,EAAW;AACT,YAAM,IAAI7H,KAAJ,CAAU,kCAAV,CAAN;AACD;;AAEDb,IAAAA,KAAK,CAAC,oDAAD,CAAL;AACA,UAAMM,cAAc,GAAGmJ,iBAAiB,CAAC7F,GAAD,EAAM8E,IAAN,EAAYzC,KAAZ,CAAxC;AACAjG,IAAAA,KAAK,CAAC,2BAAD,EAA8BM,cAA9B,CAAL,CAPiC,CAOmB;AACpD;AACA;;AAEA,UAAM4F,aAAa,GAAG,MAAMxG,KAAK,CAACgK,OAAN,CAAczD,KAAK,CAAC1E,QAApB,EAA8BjB,cAA9B,CAA5B;AACAN,IAAAA,KAAK,CAAC,oBAAD,EAAuBkG,aAAvB,CAAL;;AAEA,QAAI,CAACA,aAAa,CAACsD,YAAnB,EAAiC;AAC/B,YAAM,IAAI3I,KAAJ,CAAU,gCAAV,CAAN;AACD,KAhBgC,CAgB/B;AACF;;;AAGAoF,IAAAA,KAAK,GAAG3G,MAAM,CAACgH,MAAP,CAAchH,MAAM,CAACgH,MAAP,CAAc,EAAd,EAAkBL,KAAlB,CAAd,EAAwC;AAC9CC,MAAAA;AAD8C,KAAxC,CAAR;AAGA,UAAMuC,OAAO,CAACpC,GAAR,CAAYF,GAAZ,EAAiBF,KAAjB,CAAN;AACAjG,IAAAA,KAAK,CAAC,2BAAD,CAAL;AACD,GAzBD,MAyBO;AACLA,IAAAA,KAAK,CAAC,CAAC,CAACwI,EAAE,GAAG,CAACD,EAAE,GAAGtC,KAAN,MAAiB,IAAjB,IAAyBsC,EAAE,KAAK,KAAK,CAArC,GAAyC,KAAK,CAA9C,GAAkDA,EAAE,CAACrC,aAA3D,MAA8E,IAA9E,IAAsFsC,EAAE,KAAK,KAAK,CAAlG,GAAsG,KAAK,CAA3G,GAA+GA,EAAE,CAACgB,YAAnH,IAAmI,oBAAnI,GAA0J,yBAA3J,CAAL;AACD;;AAED,MAAIpD,yBAAJ,EAA+B;AAC7B,UAAMqC,OAAO,CAACpC,GAAR,CAAYxG,UAAU,CAACE,SAAvB,EAAkCoG,GAAlC,CAAN;AACD;;AAED,QAAMwD,MAAM,GAAG,IAAI/J,QAAQ,CAACgK,OAAb,CAAqBhG,GAArB,EAA0BqC,KAA1B,CAAf;AACAjG,EAAAA,KAAK,CAAC,6BAAD,EAAgC2J,MAAhC,CAAL;AACA,SAAOA,MAAP;AACD;;AAEDnK,OAAO,CAAC4I,YAAR,GAAuBA,YAAvB;AACA;AACA;AACA;AACA;;AAEA,SAASqB,iBAAT,CAA2B7F,GAA3B,EAAgC8E,IAAhC,EAAsCzC,KAAtC,EAA6C;AAC3C,QAAM;AACJf,IAAAA,WADI;AAEJZ,IAAAA,YAFI;AAGJ/C,IAAAA,QAHI;AAIJ6D,IAAAA;AAJI,MAKFa,KALJ;;AAOA,MAAI,CAACf,WAAL,EAAkB;AAChB,UAAM,IAAIrE,KAAJ,CAAU,2BAAV,CAAN;AACD;;AAED,MAAI,CAACU,QAAL,EAAe;AACb,UAAM,IAAIV,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,MAAI,CAACuE,QAAL,EAAe;AACb,UAAM,IAAIvE,KAAJ,CAAU,wBAAV,CAAN;AACD;;AAED,QAAMP,cAAc,GAAG;AACrBuJ,IAAAA,MAAM,EAAE,MADa;AAErBC,IAAAA,OAAO,EAAE;AACP,sBAAgB;AADT,KAFY;AAKrBC,IAAAA,IAAI,EAAG,QAAOrB,IAAK,+CAA8ChC,kBAAkB,CAACxB,WAAD,CAAc;AAL5E,GAAvB,CApB2C,CA0BxC;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAIZ,YAAJ,EAAkB;AAChBhE,IAAAA,cAAc,CAACwJ,OAAf,CAAuBE,aAAvB,GAAuC,WAAWpG,GAAG,CAACqG,IAAJ,CAAS7E,QAAQ,GAAG,GAAX,GAAiBd,YAA1B,CAAlD;AACAtE,IAAAA,KAAK,CAAC,oEAAD,EAAuEM,cAAc,CAACwJ,OAAf,CAAuBE,aAA9F,CAAL;AACD,GAHD,MAGO;AACLhK,IAAAA,KAAK,CAAC,sEAAD,CAAL;AACAM,IAAAA,cAAc,CAACyJ,IAAf,IAAwB,cAAarD,kBAAkB,CAACtB,QAAD,CAAW,EAAlE;AACD;;AAED,SAAO9E,cAAP;AACD;;AAEDd,OAAO,CAACiK,iBAAR,GAA4BA,iBAA5B;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeS,KAAf,CAAqBtG,GAArB,EAA0Bb,SAA1B,EAAqCO,OAArC,EAA8C;AAC5C,MAAIN,IAAI,GAAGoF,YAAY,CAACxE,GAAD,CAAvB;;AAEA,MAAIb,SAAJ,EAAe;AACbC,IAAAA,IAAI,GAAGA,IAAI,CAAChC,IAAL,CAAU+B,SAAV,CAAP;AACD;;AAED,MAAIO,OAAJ,EAAa;AACXN,IAAAA,IAAI,GAAGA,IAAI,CAACrC,KAAL,CAAW2C,OAAX,CAAP;AACD;;AAED,SAAON,IAAP;AACD;;AAEDxD,OAAO,CAAC0K,KAAR,GAAgBA,KAAhB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAeC,IAAf,CAAoBvG,GAApB,EAAyBwG,OAAzB,EAAkC;AAChC,QAAM7J,GAAG,GAAGqD,GAAG,CAACyB,MAAJ,EAAZ;AACA,QAAMqD,IAAI,GAAGnI,GAAG,CAACiF,YAAJ,CAAiBC,GAAjB,CAAqB,MAArB,CAAb;AACA,QAAMQ,KAAK,GAAG1F,GAAG,CAACiF,YAAJ,CAAiBC,GAAjB,CAAqB,OAArB,CAAd,CAHgC,CAGa;;AAE7C,MAAIiD,IAAI,IAAIzC,KAAZ,EAAmB;AACjB,WAAOmC,YAAY,CAACxE,GAAD,CAAnB;AACD,GAP+B,CAO9B;AACF;AACA;;;AAGA,QAAM0B,OAAO,GAAG1B,GAAG,CAAC2B,UAAJ,EAAhB;AACA,QAAMY,GAAG,GAAGF,KAAK,KAAK,MAAMX,OAAO,CAACG,GAAR,CAAY5F,UAAU,CAACE,SAAvB,CAAX,CAAjB;AACA,QAAMsK,MAAM,GAAG,MAAM/E,OAAO,CAACG,GAAR,CAAYU,GAAZ,CAArB;;AAEA,MAAIkE,MAAJ,EAAY;AACV,WAAO,IAAIzK,QAAQ,CAACgK,OAAb,CAAqBhG,GAArB,EAA0ByG,MAA1B,CAAP;AACD,GAlB+B,CAkB9B;;;AAGF,SAAOnG,SAAS,CAACN,GAAD,EAAMwG,OAAN,CAAT,CAAwBpJ,IAAxB,CAA6B,MAAM;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAO,IAAI4B,OAAJ,CAAY,MAAM,CAAE,CAApB,CAAP;AACD,GATM,CAAP;AAUD;;AAEDpD,OAAO,CAAC2K,IAAR,GAAeA,IAAf","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n/* global window */\n\nconst lib_1 = require(\"./lib\");\n\nconst Client_1 = require(\"./Client\");\n\nconst settings_1 = require(\"./settings\");\n\nexports.KEY = settings_1.SMART_KEY;\nconst debug = lib_1.debug.extend(\"oauth2\");\n\nfunction isBrowser() {\n  return typeof window === \"object\";\n}\n/**\n * Fetches the well-known json file from the given base URL.\n * Note that the result is cached in memory (until the page is reloaded in the\n * browser) because it might have to be re-used by the client\n * @param baseUrl The base URL of the FHIR server\n */\n\n\nfunction fetchWellKnownJson(baseUrl = \"/\", requestOptions) {\n  const url = String(baseUrl).replace(/\\/*$/, \"/\") + \".well-known/smart-configuration\";\n  return lib_1.getAndCache(url, requestOptions).catch(ex => {\n    throw new Error(`Failed to fetch the well-known json \"${url}\". ${ex.message}`);\n  });\n}\n\nexports.fetchWellKnownJson = fetchWellKnownJson;\n/**\n * Fetch a \"WellKnownJson\" and extract the SMART endpoints from it\n */\n\nfunction getSecurityExtensionsFromWellKnownJson(baseUrl = \"/\", requestOptions) {\n  return fetchWellKnownJson(baseUrl, requestOptions).then(meta => {\n    if (!meta.authorization_endpoint || !meta.token_endpoint) {\n      throw new Error(\"Invalid wellKnownJson\");\n    }\n\n    return {\n      registrationUri: meta.registration_endpoint || \"\",\n      authorizeUri: meta.authorization_endpoint,\n      tokenUri: meta.token_endpoint\n    };\n  });\n}\n/**\n * Fetch a `CapabilityStatement` and extract the SMART endpoints from it\n */\n\n\nfunction getSecurityExtensionsFromConformanceStatement(baseUrl = \"/\", requestOptions) {\n  return lib_1.fetchConformanceStatement(baseUrl, requestOptions).then(meta => {\n    const nsUri = \"http://fhir-registry.smarthealthit.org/StructureDefinition/oauth-uris\";\n    const extensions = (lib_1.getPath(meta || {}, \"rest.0.security.extension\") || []).filter(e => e.url === nsUri).map(o => o.extension)[0];\n    const out = {\n      registrationUri: \"\",\n      authorizeUri: \"\",\n      tokenUri: \"\"\n    };\n\n    if (extensions) {\n      extensions.forEach(ext => {\n        if (ext.url === \"register\") {\n          out.registrationUri = ext.valueUri;\n        }\n\n        if (ext.url === \"authorize\") {\n          out.authorizeUri = ext.valueUri;\n        }\n\n        if (ext.url === \"token\") {\n          out.tokenUri = ext.valueUri;\n        }\n      });\n    }\n\n    return out;\n  });\n}\n/**\n * This works similarly to `Promise.any()`. The tasks are objects containing a\n * request promise and it's AbortController. Returns a promise that will be\n * resolved with the return value of the first successful request, or rejected\n * with an aggregate error if all tasks fail. Any requests, other than the first\n * one that succeeds will be aborted.\n */\n\n\nfunction any(tasks) {\n  const len = tasks.length;\n  const errors = [];\n  let resolved = false;\n  return new Promise((resolve, reject) => {\n    function onSuccess(task, result) {\n      task.complete = true;\n\n      if (!resolved) {\n        resolved = true;\n        tasks.forEach(t => {\n          if (!t.complete) {\n            t.controller.abort();\n          }\n        });\n        resolve(result);\n      }\n    }\n\n    function onError(error) {\n      if (errors.push(error) === len) {\n        reject(new Error(errors.map(e => e.message).join(\"; \")));\n      }\n    }\n\n    tasks.forEach(t => {\n      t.promise.then(result => onSuccess(t, result), onError);\n    });\n  });\n}\n/**\n * Given a FHIR server, returns an object with it's Oauth security endpoints\n * that we are interested in. This will try to find the info in both the\n * `CapabilityStatement` and the `.well-known/smart-configuration`. Whatever\n * Arrives first will be used and the other request will be aborted.\n * @param [baseUrl] Fhir server base URL\n * @param [env] The Adapter\n */\n\n\nfunction getSecurityExtensions(env, baseUrl = \"/\") {\n  const AbortController = env.getAbortController();\n  const abortController1 = new AbortController();\n  const abortController2 = new AbortController();\n  return any([{\n    controller: abortController1,\n    promise: getSecurityExtensionsFromWellKnownJson(baseUrl, {\n      signal: abortController1.signal\n    })\n  }, {\n    controller: abortController2,\n    promise: getSecurityExtensionsFromConformanceStatement(baseUrl, {\n      signal: abortController2.signal\n    })\n  }]);\n}\n\nexports.getSecurityExtensions = getSecurityExtensions;\n/**\n * Starts the SMART Launch Sequence.\n * > **IMPORTANT**:\n *   `authorize()` will end up redirecting you to the authorization server.\n *    This means that you should not add anything to the returned promise chain.\n *    Any code written directly after the authorize() call might not be executed\n *    due to that redirect!\n * @param env\n * @param [params]\n * @param [_noRedirect] If true, resolve with the redirect url without trying to redirect to it\n */\n\nasync function authorize(env, params = {}, _noRedirect = false) {\n  // Obtain input\n  const {\n    redirect_uri,\n    clientSecret,\n    fakeTokenResponse,\n    patientId,\n    encounterId,\n    client_id,\n    target,\n    width,\n    height,\n    completeInTarget\n  } = params;\n  let {\n    iss,\n    launch,\n    fhirServiceUrl,\n    redirectUri,\n    scope = \"\",\n    clientId\n  } = params;\n  const url = env.getUrl();\n  const storage = env.getStorage(); // For these three an url param takes precedence over inline option\n\n  iss = url.searchParams.get(\"iss\") || iss;\n  fhirServiceUrl = url.searchParams.get(\"fhirServiceUrl\") || fhirServiceUrl;\n  launch = url.searchParams.get(\"launch\") || launch;\n\n  if (!clientId) {\n    clientId = client_id;\n  }\n\n  if (!redirectUri) {\n    redirectUri = redirect_uri;\n  }\n\n  if (!redirectUri) {\n    redirectUri = env.relative(\".\");\n  } else {\n    redirectUri = env.relative(redirectUri);\n  }\n\n  const serverUrl = String(iss || fhirServiceUrl || \"\"); // Validate input\n\n  if (!serverUrl) {\n    throw new Error(\"No server url found. It must be specified as `iss` or as \" + \"`fhirServiceUrl` parameter\");\n  }\n\n  if (iss) {\n    debug(\"Making %s launch...\", launch ? \"EHR\" : \"standalone\");\n  } // append launch scope if needed\n\n\n  if (launch && !scope.match(/launch/)) {\n    scope += \" launch\";\n  } // If `authorize` is called, make sure we clear any previous state (in case\n  // this is a re-authorize)\n\n\n  const oldKey = await storage.get(settings_1.SMART_KEY);\n  await storage.unset(oldKey); // create initial state\n\n  const stateKey = lib_1.randomString(16);\n  const state = {\n    clientId,\n    scope,\n    redirectUri,\n    serverUrl,\n    clientSecret,\n    tokenResponse: {},\n    key: stateKey,\n    completeInTarget\n  };\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true;\n\n  if (fullSessionStorageSupport) {\n    await storage.set(settings_1.SMART_KEY, stateKey);\n  } // fakeTokenResponse to override stuff (useful in development)\n\n\n  if (fakeTokenResponse) {\n    Object.assign(state.tokenResponse, fakeTokenResponse);\n  } // Fixed patientId (useful in development)\n\n\n  if (patientId) {\n    Object.assign(state.tokenResponse, {\n      patient: patientId\n    });\n  } // Fixed encounterId (useful in development)\n\n\n  if (encounterId) {\n    Object.assign(state.tokenResponse, {\n      encounter: encounterId\n    });\n  }\n\n  let redirectUrl = redirectUri + \"?state=\" + encodeURIComponent(stateKey); // bypass oauth if fhirServiceUrl is used (but iss takes precedence)\n\n  if (fhirServiceUrl && !iss) {\n    debug(\"Making fake launch...\");\n    await storage.set(stateKey, state);\n\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // Get oauth endpoints and add them to the state\n\n\n  const extensions = await getSecurityExtensions(env, serverUrl);\n  Object.assign(state, extensions);\n  await storage.set(stateKey, state); // If this happens to be an open server and there is no authorizeUri\n\n  if (!state.authorizeUri) {\n    if (_noRedirect) {\n      return redirectUrl;\n    }\n\n    return await env.redirect(redirectUrl);\n  } // build the redirect uri\n\n\n  const redirectParams = [\"response_type=code\", \"client_id=\" + encodeURIComponent(clientId || \"\"), \"scope=\" + encodeURIComponent(scope), \"redirect_uri=\" + encodeURIComponent(redirectUri), \"aud=\" + encodeURIComponent(serverUrl), \"state=\" + encodeURIComponent(stateKey)]; // also pass this in case of EHR launch\n\n  if (launch) {\n    redirectParams.push(\"launch=\" + encodeURIComponent(launch));\n  }\n\n  redirectUrl = state.authorizeUri + \"?\" + redirectParams.join(\"&\");\n\n  if (_noRedirect) {\n    return redirectUrl;\n  }\n\n  if (target && isBrowser()) {\n    let win;\n    win = await lib_1.getTargetWindow(target, width, height);\n\n    if (win !== self) {\n      try {\n        // Also remove any old state from the target window and then\n        // transfer the current state there\n        win.sessionStorage.removeItem(oldKey);\n        win.sessionStorage.setItem(stateKey, JSON.stringify(state));\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.sessionStorage. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        win = self;\n      }\n    }\n\n    if (win !== self) {\n      try {\n        win.location.href = redirectUrl;\n        self.addEventListener(\"message\", onMessage);\n      } catch (ex) {\n        lib_1.debug(`Failed to modify window.location. Perhaps it is from different origin?. Failing back to \"_self\". %s`, ex);\n        self.location.href = redirectUrl;\n      }\n    } else {\n      self.location.href = redirectUrl;\n    }\n\n    return;\n  } else {\n    return await env.redirect(redirectUrl);\n  }\n}\n\nexports.authorize = authorize;\n/**\n * Checks if called within a frame. Only works in browsers!\n * If the current window has a `parent` or `top` properties that refer to\n * another window, returns true. If trying to access `top` or `parent` throws an\n * error, returns true. Otherwise returns `false`.\n */\n\nfunction isInFrame() {\n  try {\n    return self !== top && parent !== self;\n  } catch (e) {\n    return true;\n  }\n}\n\nexports.isInFrame = isInFrame;\n/**\n * Checks if called within another window (popup or tab). Only works in browsers!\n * To consider itself called in a new window, this function verifies that:\n * 1. `self === top` (not in frame)\n * 2. `!!opener && opener !== self` The window has an opener\n * 3. `!!window.name` The window has a `name` set\n */\n\nfunction isInPopUp() {\n  try {\n    return self === top && !!opener && opener !== self && !!window.name;\n  } catch (e) {\n    return false;\n  }\n}\n\nexports.isInPopUp = isInPopUp;\n/**\n * Another window can send a \"completeAuth\" message to this one, making it to\n * navigate to e.data.url\n * @param e The message event\n */\n\nfunction onMessage(e) {\n  if (e.data.type == \"completeAuth\" && e.origin === new URL(self.location.href).origin) {\n    window.removeEventListener(\"message\", onMessage);\n    window.location.href = e.data.url;\n  }\n}\n\nexports.onMessage = onMessage;\n/**\n * The completeAuth function should only be called on the page that represents\n * the redirectUri. We typically land there after a redirect from the\n * authorization server..\n */\n\nasync function completeAuth(env) {\n  var _a, _b, _c, _d;\n\n  const url = env.getUrl();\n  const Storage = env.getStorage();\n  const params = url.searchParams;\n  let key = params.get(\"state\");\n  const code = params.get(\"code\");\n  const authError = params.get(\"error\");\n  const authErrorDescription = params.get(\"error_description\");\n\n  if (!key) {\n    key = await Storage.get(settings_1.SMART_KEY);\n  } // Start by checking the url for `error` and `error_description` parameters.\n  // This happens when the auth server rejects our authorization attempt. In\n  // this case it has no other way to tell us what the error was, other than\n  // appending these parameters to the redirect url.\n  // From client's point of view, this is not very reliable (because we can't\n  // know how we have landed on this page - was it a redirect or was it loaded\n  // manually). However, if `completeAuth()` is being called, we can assume\n  // that the url comes from the auth server (otherwise the app won't work\n  // anyway).\n\n\n  if (authError || authErrorDescription) {\n    throw new Error([authError, authErrorDescription].filter(Boolean).join(\": \"));\n  }\n\n  debug(\"key: %s, code: %O\", key, code); // key might be coming from the page url so it might be empty or missing\n\n  if (!key) {\n    throw new Error(\"No 'state' parameter found. Please (re)launch the app.\");\n  } // Check if we have a previous state\n\n\n  let state = await Storage.get(key);\n  const fullSessionStorageSupport = isBrowser() ? lib_1.getPath(env, \"options.fullSessionStorageSupport\") : true; // If we are in a popup window or an iframe and the authorization is\n  // complete, send the location back to our opener and exit.\n\n  if (isBrowser() && state && !state.completeInTarget) {\n    const inFrame = isInFrame();\n    const inPopUp = isInPopUp(); // we are about to return to the opener/parent where completeAuth will\n    // be called again. In rare cases the opener or parent might also be\n    // a frame or popup. Then inFrame or inPopUp will be true but we still\n    // have to stop going up the chain. To guard against that weird form of\n    // recursion we pass one additional parameter to the url which we later\n    // remove.\n\n    if ((inFrame || inPopUp) && !url.searchParams.get(\"complete\")) {\n      url.searchParams.set(\"complete\", \"1\");\n      const {\n        href,\n        origin\n      } = url;\n\n      if (inFrame) {\n        parent.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n      }\n\n      if (inPopUp) {\n        opener.postMessage({\n          type: \"completeAuth\",\n          url: href\n        }, origin);\n        window.close();\n      }\n\n      return new Promise(() => {});\n    }\n  }\n\n  url.searchParams.delete(\"complete\"); // Do we have to remove the `code` and `state` params from the URL?\n\n  const hasState = params.has(\"state\");\n\n  if (isBrowser() && lib_1.getPath(env, \"options.replaceBrowserHistory\") && (code || hasState)) {\n    // `code` is the flag that tell us to request an access token.\n    // We have to remove it, otherwise the page will authorize on\n    // every load!\n    if (code) {\n      params.delete(\"code\");\n      debug(\"Removed code parameter from the url.\");\n    } // If we have `fullSessionStorageSupport` it means we no longer\n    // need the `state` key. It will be stored to a well know\n    // location - sessionStorage[SMART_KEY]. However, no\n    // fullSessionStorageSupport means that this \"well know location\"\n    // might be shared between windows and tabs. In this case we\n    // MUST keep the `state` url parameter.\n\n\n    if (hasState && fullSessionStorageSupport) {\n      params.delete(\"state\");\n      debug(\"Removed state parameter from the url.\");\n    } // If the browser does not support the replaceState method for the\n    // History Web API, the \"code\" parameter cannot be removed. As a\n    // consequence, the page will (re)authorize on every load. The\n    // workaround is to reload the page to new location without those\n    // parameters. If that is not acceptable replaceBrowserHistory\n    // should be set to false.\n\n\n    if (window.history.replaceState) {\n      window.history.replaceState({}, \"\", url.href);\n    }\n  } // If the state does not exist, it means the page has been loaded directly.\n\n\n  if (!state) {\n    throw new Error(\"No state found! Please (re)launch the app.\");\n  } // Assume the client has already completed a token exchange when\n  // there is no code (but we have a state) or access token is found in state\n\n\n  const authorized = !code || ((_b = (_a = state) === null || _a === void 0 ? void 0 : _a.tokenResponse) === null || _b === void 0 ? void 0 : _b.access_token); // If we are authorized already, then this is just a reload.\n  // Otherwise, we have to complete the code flow\n\n  if (!authorized && state.tokenUri) {\n    if (!code) {\n      throw new Error(\"'code' url parameter is required\");\n    }\n\n    debug(\"Preparing to exchange the code for access token...\");\n    const requestOptions = buildTokenRequest(env, code, state);\n    debug(\"Token request options: %O\", requestOptions); // The EHR authorization server SHALL return a JSON structure that\n    // includes an access token or a message indicating that the\n    // authorization request has been denied.\n\n    const tokenResponse = await lib_1.request(state.tokenUri, requestOptions);\n    debug(\"Token response: %O\", tokenResponse);\n\n    if (!tokenResponse.access_token) {\n      throw new Error(\"Failed to obtain access token.\");\n    } // save the tokenResponse so that we don't have to re-authorize on\n    // every page reload\n\n\n    state = Object.assign(Object.assign({}, state), {\n      tokenResponse\n    });\n    await Storage.set(key, state);\n    debug(\"Authorization successful!\");\n  } else {\n    debug(((_d = (_c = state) === null || _c === void 0 ? void 0 : _c.tokenResponse) === null || _d === void 0 ? void 0 : _d.access_token) ? \"Already authorized\" : \"No authorization needed\");\n  }\n\n  if (fullSessionStorageSupport) {\n    await Storage.set(settings_1.SMART_KEY, key);\n  }\n\n  const client = new Client_1.default(env, state);\n  debug(\"Created client instance: %O\", client);\n  return client;\n}\n\nexports.completeAuth = completeAuth;\n/**\n * Builds the token request options. Does not make the request, just\n * creates it's configuration and returns it in a Promise.\n */\n\nfunction buildTokenRequest(env, code, state) {\n  const {\n    redirectUri,\n    clientSecret,\n    tokenUri,\n    clientId\n  } = state;\n\n  if (!redirectUri) {\n    throw new Error(\"Missing state.redirectUri\");\n  }\n\n  if (!tokenUri) {\n    throw new Error(\"Missing state.tokenUri\");\n  }\n\n  if (!clientId) {\n    throw new Error(\"Missing state.clientId\");\n  }\n\n  const requestOptions = {\n    method: \"POST\",\n    headers: {\n      \"content-type\": \"application/x-www-form-urlencoded\"\n    },\n    body: `code=${code}&grant_type=authorization_code&redirect_uri=${encodeURIComponent(redirectUri)}`\n  }; // For public apps, authentication is not possible (and thus not required),\n  // since a client with no secret cannot prove its identity when it issues a\n  // call. (The end-to-end system can still be secure because the client comes\n  // from a known, https protected endpoint specified and enforced by the\n  // redirect uri.) For confidential apps, an Authorization header using HTTP\n  // Basic authentication is required, where the username is the app’s\n  // client_id and the password is the app’s client_secret (see example).\n\n  if (clientSecret) {\n    requestOptions.headers.Authorization = \"Basic \" + env.btoa(clientId + \":\" + clientSecret);\n    debug(\"Using state.clientSecret to construct the authorization header: %s\", requestOptions.headers.Authorization);\n  } else {\n    debug(\"No clientSecret found in state. Adding the clientId to the POST body\");\n    requestOptions.body += `&client_id=${encodeURIComponent(clientId)}`;\n  }\n\n  return requestOptions;\n}\n\nexports.buildTokenRequest = buildTokenRequest;\n/**\n * @param env\n * @param [onSuccess]\n * @param [onError]\n */\n\nasync function ready(env, onSuccess, onError) {\n  let task = completeAuth(env);\n\n  if (onSuccess) {\n    task = task.then(onSuccess);\n  }\n\n  if (onError) {\n    task = task.catch(onError);\n  }\n\n  return task;\n}\n\nexports.ready = ready;\n/**\n * This function can be used when you want to handle everything in one page\n * (no launch endpoint needed). You can think of it as if it does:\n * ```js\n * authorize(options).then(ready)\n * ```\n *\n * **Be careful with init()!** There are some details you need to be aware of:\n *\n * 1. It will only work if your launch_uri is the same as your redirect_uri.\n *    While this should be valid, we can’t promise that every EHR will allow you\n *    to register client with such settings.\n * 2. Internally, `init()` will be called twice. First it will redirect to the\n *    EHR, then the EHR will redirect back to the page where init() will be\n *    called again to complete the authorization. This is generally fine,\n *    because the returned promise will only be resolved once, after the second\n *    execution, but please also consider the following:\n *    - You should wrap all your app’s code in a function that is only executed\n *      after `init()` resolves!\n *    - Since the page will be loaded twice, you must be careful if your code\n *      has global side effects that can persist between page reloads\n *      (for example writing to localStorage).\n * 3. For standalone launch, only use init in combination with offline_access\n *    scope. Once the access_token expires, if you don’t have a refresh_token\n *    there is no way to re-authorize properly. We detect that and delete the\n *    expired access token, but it still means that the user will have to\n *    refresh the page twice to re-authorize.\n * @param env The adapter\n * @param options The authorize options\n */\n\nasync function init(env, options) {\n  const url = env.getUrl();\n  const code = url.searchParams.get(\"code\");\n  const state = url.searchParams.get(\"state\"); // if `code` and `state` params are present we need to complete the auth flow\n\n  if (code && state) {\n    return completeAuth(env);\n  } // Check for existing client state. If state is found, it means a client\n  // instance have already been created in this session and we should try to\n  // \"revive\" it.\n\n\n  const storage = env.getStorage();\n  const key = state || (await storage.get(settings_1.SMART_KEY));\n  const cached = await storage.get(key);\n\n  if (cached) {\n    return new Client_1.default(env, cached);\n  } // Otherwise try to launch\n\n\n  return authorize(env, options).then(() => {\n    // `init` promises a Client but that cannot happen in this case. The\n    // browser will be redirected (unload the page and be redirected back\n    // to it later and the same init function will be called again). On\n    // success, authorize will resolve with the redirect url but we don't\n    // want to return that from this promise chain because it is not a\n    // Client instance. At the same time, if authorize fails, we do want to\n    // pass the error to those waiting for a client instance.\n    return new Promise(() => {});\n  });\n}\n\nexports.init = init;"]},"metadata":{},"sourceType":"script"}